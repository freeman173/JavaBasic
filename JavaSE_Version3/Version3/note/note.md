这是第三次搞java基础了!

2022/12/11:

计算机编程语言的介绍：
    第一代语言：机器语言（二进制形式存在）
    第二代语言:汇编语言：汇编语言是直接在硬件之上工作的编程语言，指令就是汇编语言写的。
    第三代语言：高级语言：c/c++、java、python

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

java语言概述：
    应用方向：
        企业级应用：大企业的软件系统、各种类型网站。java的安全机制以及跨平台的特性使得其在分布式系统领域拥有广泛应用。

        安卓平台：暂时不感兴趣
        
        移动应用领域：暂时不感兴趣
        
        大数据平台开发：hadoop等（用java开发的）


    java的三个重要特点：
        面向对象：
            
        健壮性：去掉了指针、内存申请这些东西，增加了一个垃圾回收功能，自动回收空闲的内存。

        跨平台性：
            只要装了虚拟机，都可以跑java代码。


――――――――――――――――――――――――――――――――――――――――――――――――――-――――――――
java的两个核心机制：

1、JVM(Java Virtal Machine)：
   JVM是一个虚拟计算机，具有指令集并使用不同的区域；
   不同的平台有不同的虚拟机(不同的土壤打不同的地基)；
   虚拟机屏蔽了底层运行平台的差异，实现“一次编译，到处运行“。
  

2、javac：
    javac是一种编译器，将.java转化为jvm可以识别的.class文件



3、jdk、jre、jvm之间的关系：
   jvm在倒数第二层 由他可以在（最后一层的）各种平台上运行；
   Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库；
   Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm的一些工具



4、jvm的核心在于内存管理：

   程序计数器：字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令。

   虚拟机栈：
       线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)
    用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
   
   本地方法栈：
       区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，
     而本地方法栈则为虚拟机使用到的 Native 方法服务。 

   堆：
       JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区。

   方法区：
       属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。



5、垃圾回收机制：
    程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有）。 
在 Java 世界中，几乎所有的对象实例都在堆中存放，所以垃圾回收也主要是针对堆来进行的。
jvm自动进行，程序猿无需干预。


    在 JVM 的眼中，垃圾就是指那些在堆中存在的，已经“死亡”的对象。而对于“死亡”的定义，我们
可以简单的将其理解为“不可能再被任何途径使用的对象”

Java 中有四种引用类型，分别为：
   强引用（Strong Reference）：如Object obj = new Object()，这类引用是 Java 程序中最普遍的。
只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

   软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。

   弱引用（Weak Reference）：它也是用来描述非必须对象的，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

   虚引用：也称为幻引用，最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
   
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
关键字与保留字：
    关键字：java语言赋予了其特殊含义，有专门的用途；所有字母均为小写。
    保留字：尚未使用，但以后版本可能会作为关键字使用。


标识符：程序猿自己起的名字。
   规则：
        英文字母、阿拉伯数字、"_"或者"$"组成；
        数字不能开头，区分大小写，长度无限制，不能有空格；
        不能用关键字但可以包含；
     
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

变量：内存中的一块存储区域；用于在内存中保存数据。

   注意点：变量的作用域在其定义的最近的一对“{}”之内；局部变量使用时一定得初始化！



变量的分类（按数据类型）：
    基本数据类型：
        数值型：
            整型：byte、short、int、long
            浮点型：float、double
        字符型：char
        布尔型：boolean

    引用数据类型：
            类、接口、数组

基本类型跟引用类型的区别：
   基本数据类型存储在栈中。
   而引用数据类型首先要在栈上给其分配一块内存（存放其具体内容所在内存的地址），
而对象的具体信息存储在堆内存上，由栈上引用指向堆中对象的地址。


整型：
    byte：1字节（8bit）
    short：2字节
    int：4字节（最常用）
    long：8字节
    注：字节（byte）是计算机中最基本的存储单元；bit是计算机的最小存储单位。


浮点型：
 float：4字节，可以精确到7位数字。须在后面加"f/F"。
double：8字节，可以精确到14为数字，默认使用此类型



字符类型char：
    存储空间：2字节


基本数据类型之间的运算规则:

    自动类型提升：当容量小的数据类型与容量大的数据类型做运算时，先自动提升为容量大的数据类型，然后再做计算。
         (byte/char/short)-->int-->long-->float-->double

    注：
       float占4个字节、long占8个字节，但float类型的数值容量大于long（float类型在内存中的存放方式特别）
       byte/char/short三者做运算时，都先转换为int。


    强制类型转换：就是自动类型提升的逆运算
        1、需要使用强转符；2、可能导致精度损失（去尾法……）

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
String数据类型

string为引用类型；
string可以和8种基本类型变量做连接运算（+），类型仍为string类型。


双引号括起来的字符串，是不可变的；
字符串直接存储在“方法区”的“字符串常量池”当中的（字符串在实际的开发中使用太频繁）；



――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

常量是指在程序的整个运行过程中值保持不变的量，是不能改变的数据。

被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。

final修饰：
    基本数据类型，则该引用为常量，该值无法修改；
    引用数据类型，比如对象，则该对象本身可以修改，但指向该对象或数组的地址的引用不能修改。


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
运算符：

++:
当++在前面的时候，先自加1，后进行赋值操作；当++在后面的时候，先进行赋值操作，再自加1。(有括号也一样)


赋值运算符（=）与比较运算符（==）的区别：
    一个用作赋值，一个用做比较。


逻辑运算符：
    见图片



三元运算符：
    （条件表达式）？表达式1：表达式2


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――


for循环的使用：
1、四个要素：
(1)初始条件、（2）循环条件、（3）循环体、（4）迭代条件

for((1);(2);(4))
{
(3)
}
执行过程：（1）-->(2)-->(3)-->(4)-->(2)-->(3)-->(4)-->……………………。



while循环：
(1)
while((2)){
(3)
(4)

}
执行过程：（1）-->(2)-->(3)-->(4)-->(2)-->(3)-->(4)-->……………………。


注：while循环与for循环的唯一区别：while的(1)与for的（1）作用范围不一样。



do-while循环：
(1)
do{
    (3)
    (4)
}while((2));
执行过程：（1)-->(3)-->(4)-->(2)-->(3)-->(4)-->……………………。

注：相比于while，至少得执行一次循环体！



break与continue：
    break：结束当前循环（默认结束最近的循环结构）。
    continue：结束本次循环。


――――――――――――――――――――――――――――――――――――――――――――――――――
数组：

特点：
    有序排列；
    数组为引用类型。数组的元素可以是基本类型，也可以是引用数据类型；
    创建数组对象会在内存中开辟一整块连续空间，长度一旦确定就不能修改；


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
java基础部分的复习：

数组：
1、什么是数组
    （1）数组是储存在堆上的对象，可以保存多个同类型变量。
    （2）数组就像身上编了号站成一排的人，要找第10个人很容易，根据人身上的编号很快就能找到。
    （3）插入、删除慢。
    （4）Java中的数组是定长的,无法动态增加长度。

2、 java在声明一个数组的过程中，是如何分配内存的，初始化方式有几种？（基础题）
    数组在初始化过程中，有两种初始化方式：静态和动态初始化，两者的区别在于由系统指定长度还是由程序员指定长度，
然后系统根据指定的长度在堆内存中寻找一块大小符合的连续内存块分配给数组，并根据数组类型初始化每个数组元素的值，
初始化完之后，数组长度不可改变。


3、什么是引用变量和引用对象，他们之间有什么联系？
所有的基础类型和引用类型变量都是存储在自己的方法栈区中的，而对象（包括数组、普通java对象）总是存储在堆内存中的；
而所谓的引用是指将方法栈区中的变量指向堆内存中的对象。在程序中通过引用变量访问属性时，就会映射到变量指向的对象，
使该对象变成引用对象。

注：堆中的对象如何被回收：通过在对象头部分配一个空间，来保存该对象被引用的次数。对象被其他对象引用，则它的计数加1，
删除该对象的引用，计数减1，当该对象计数为0时，会被回收。



变量的生存周期：
见图片笔记
常量的生存周期：
常量存放在jvm方法区的常量池；至于生存周期，目前不重要（后面有需要再来了解其原理）

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            面向对象

一、这块学习的三条主线
1、java类以及类的成员；属性、方法、构造器、代码块、内部类
2、面向对象的三大特征：封装、继承、多态

    封装：
        禁止直接访问一个对象中数据的实际表示，而是应该通过操作接口来访问。
    继承：

    多态:
    




3、其它关键字：this、super、interface、……




对象的内存解析：
    方法区主要存储类信息：
            1、类型信息
            2、成员变量
            3、方法
注：其余原理见面向对象图片文件夹；目前了解到这个程度足够了。




匿名对象:
    创建的对象没有赋值给变量名即为匿名对象；只能被调用一次。



重载:
    概念：同一个类中，允许存在一个以上的同名方法。（对应位置上的参数类型不同或者个数必须不同。）



关于变量的赋值问题：
    变量是基本类型，赋值为变量保存的数据值。
    变量是引用类型，赋值为变量保存的地址值。


封装： 
    设计思想：该隐藏的部分隐藏起来，该暴露的就暴露出来。
    具体体现：将类的属性私有化。提供公共的set/get方法来操作属性值。


四种权限修饰符（权限从小到大）:private、省略（不加修饰符）、protected、public。这四种
修饰符体现了类及其内部结构被调用时的可见性大小。



构造器（也称构造方法）：
    如果没有显示定义构造器，系统就会提供一个无参构造器；如果你提供构造方法，系统不会给出默认的无参构造方法：
  这时，如果你还想使用无参数构造，只能自己给出；
   建议：永远自己给出无参构造。


对象属性的赋值顺序：
    默认初始化、显示初始化（定义类时，就给属性一个预定值）、构造器初始化、set赋值。

javabean：
    公共类；
    有一个公共无参构造器；
    有属性与对应的get、set方法。


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
this：
this: 代表当前类对象的引用；可以调用自身的属性、方法（包括构造方法）
this调用构造器：
    可以在类的构造器中，显示地使用“this(参数列表)”来调用其他构造器，调用语句必须声明在首行且只能有一个，不能调用自己。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

java中，可以出现汉字字符：
    java是以unicode作为编码方式的。unicode是一个定长的编码标准，每个字符都是2个字节，也就是1个char类型的空间。
    再比如utf8是一个变长编码标准，可以以1~4个字节表示一个字符，而中文占3个字节，ascII字符占1个字节。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                                    继承

1、继承的好处？
    减少代码冗余、方便功能扩展、多态的前提。 

2、
子类继承父类后，子类就可以获取父类声明中的所有属性与方法。
    注：私有属性也继承了，只是因为封装性的影响不能直接调用；

3、 子类是不可以继承父类的构造函数只能调用。
    继承(extends)的含义其实是“扩展”，子类完全没必要扩展父类的构造函数，
因为每次调子类的时候都会“自动运行”它父类的构造函数。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
重写：子类继承父类后，可以对父类的方法进行一个覆盖重写操作；重写以后，通过子类调用父类的同名方法时，就执行这个重写的方法。

重写规定：
    方法名、形参列表与父类的被重写方法一致；重写后的权限符不能小于父类（父类私有的方法不能被重写）。
    
    返回值类型：
        父类被重写方法返回void，子类重写方法返回void。
        父类被重写方法返回基本数据类型，子类重写方法返回相同的基本数据类型。
         父类被重写方法返回A类型，子类重写方法返回A或者A的子类。


重写与重载的区别：
    了然于胸！

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            super关键字

super代表父类对象的引用；可以调用父类的属性、方法（包括构造方法：必须声明在子类构造器的首行）

子类实例化对象的全过程：
   当我们调用子类构造器创建子类对象时，一定会调用其父类构造器，直到调用了Object的构造器为止：
        运行子类构造器之前，必须先执行父类构造器；
        若父类只有无参构造器，则调用父类构造器的语句可以省略。（自动调用）
        若父类存在有参构造器，则需要显示调用父类的有参构造。    

   在创建子类对象时，虽然调用了父类的构造器，但自始至终就只创建了一个子类对象。


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                        多态
多态：一个事物的多种形态。
对象的多态：父类引用指向子类对象。

多态的使用前提：继承与方法重写。

向上转型：父类对象的引用指向子类对象。
规则：
    1、父类对象的引用可以指向子类对象
    2、一个父类的引用不可以访问其子类对象新增加的成员（属性和方法）。
    3、可以使用 引用对象 instanceof 类名：判断该引用型变量所指的对象是否属于该类或该类的子类。
        
编译期与运行期：
    编译期分配内存：并不是说在编译期就把程序所需要的空间在内存中分配好，而是说在编译期
生成的代码中产生一些指令，在运行代码时通过这些指令把程序所需的内存分配好。只不过在编译期的时候就知道分配的大小，并且知道这些内存的位置。
    运行期分配内存：是指只有在运行期才确定内存的大小，存放的位置。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

Object:一个类时候如果没有明确的继承一个父类的话，那么它就是Object的子类。


面试题：final、finally、finalize之间的区别？
final:修饰类（不能被继承）、方法（不能被重写）、变量（给定初始值之后就不能变咯）

finally：在异常处理时，try块中的内容是在无异常时执行到结束；catch块中的内容，是在try块内容发生catch所声明的异常时，
跳转到catch块中执行；finally块则是无论异常是否发生，都会执行finally块的内容。

finalize：object中的一个方法，finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。


“==”：
    基本数据类型：比较的是他们的值是否相同。
    引用数据类型：比较的是他们的内存地址是否同一地址。

equals():
    object对象中的方法：Object中的equals方法实际使用的也是==操作符，、
比较的是他们的内存地址是否同一地址。
    重写了equals方法的类：实现该类自己的equals方法比较逻辑
，一般是比较对象的内容是否相同，比如String类。


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                        包装类

为八种基本类型定义了8种包装类，使得其具有类的特征。

string、基本类、包装类之间的转换：
    自动装拆箱（jdk1.5之后出现的新特性）：
        装箱：把基本类型的数据，包装到包装类中。
        拆箱：在包装类中取出基本数据类型的数据。

            Integer i=100;//自动装箱为对象。
            int n=i;//自动拆箱为基本类型。

        
这一块比较简单，简单查一下资料就行！
    

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                        static
1、可以用来修饰内部类、属性、方法、代码块。

2、静态变量
    静态变量的加载随着类的加载而加载，早于对象的创建（存在方法区的静态域中且只有一份，类只加载一次）；

3、静态方法
    在静态方法中，只能调用静态变量或者属性；
    在非静态方法中，可以调用静态变量或者属性。

4、代码块
    静态代码块：
        随着类的加载而执行且只执行一次；
        如果一个类定义了多个代码块，则按照声明的先后顺序执行；

    非静态代码块：
        随着对象的创建而执行；

5、执行顺序的一个梳理：
当加载Demo类时，JVM会去初始化该类父类的静态代码块与静态变量（按声明顺序）， 父类的静态代码块与静态变量运行完后去执行子类的静态代码块与静态变量；
JVM再去初始化父类中的普通代码块与普通成员变量（按声明顺序），当父类的普通代码块执行完毕后又会调用父类的构造方法；
父类的构造方法执行完毕后，JVM又会去看子类中有没有普通代码块，如果有则执行；执行完毕后，会去调用子
类的构造方法。

静态变量和静态方法是根据调用顺序来执行的。


6、类静态属性跟实例变量的区别：
    随着类加载而加载，只初始化一次（JVM加载类时执行，仅执行一次）；存在于方法的静态域。


7、 类的初始化
    类的实例化是指创建一个类的实例(对象)的过程；
    类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，
 是类生命周期中的一个阶段。
    
    类初始化的时机：
        使用new关键字实例化对象的时候；
        读取或设置一个类的静态字段（被final修饰，已在编译器把结果放入常量池的静态字段除外）的时候；
        调用一个类的静态方法的时候；
        当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），
     虚拟机会先初始化这个主类。
        




――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            final

“final”名为最终的意思，修饰的变量均为常量。


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                        抽象类与抽象方法

0、
抽象类：抽象就是从多个事物中将共性的，本质的内容抽取出来。
抽象方法：多个对象都具备相同的功能，但是功能具体内容有所不同，
只抽取了功能定义，并未抽取功能主体。
abstract不能修饰私有方法、静态方法、final方法。


1、抽象类：将一个父类设计得十分抽象，以至于其没有具体实例。
    抽象类不能被实例化；
    抽象类一定有构造器（子类对象实例化需要调用）；
    可以有自己的数据成员，也可以有非abstarct的成员方法。

2、抽象类跟普通类的区别：
    在抽象类当中，可以允许普通方法有主体，抽象方法只需要申明，不需要实现；
    含有抽象方法的类，必须要申明为抽象类（抽象类它一定要有abstract关键词修饰）；
    抽象的子类必须要实现抽象类当中的所有抽象方法，否则的话，这个子类也是抽象类；
    抽象类的访问权限不能为“private”，因为它要被继承；

3、抽象方法
    只有方法的声明，无方法体；
    包含抽象方法的类，一定是抽象类（一个抽象类里面没有一个抽象方法可用来禁止产生这种类的对象。）；


小知识：
    一个java文件可以有多个类，但只能有一个Public修饰的类（.java文件的文件名必须是public类的类名);
    编译.java文件的时候，它会给每一个类生成一个.class文件;


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                             接口

1、
有时候从上面抽取部分行为特征，但彼此之间又没有"is-a"的关系，就需要用到接口；
继承是一个“是不是”，接口是“能不能”的关系；
接口与类是并列的结构；
接口不能被实例化；
如果类未实现接口的所有抽象方法，此类为抽象类；
接口之间支持多继承。


2、定义接口：
见代码“twelve.demo3”

3、一个接口的面试题
见代码“twelve.demo3”


――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            内部类

1、一个类定义在另一个类的内部，就是内部类

2、内部类的分类：
    成员内部类：
        静态：
        非静态：
    局部内部类：(用的少，暂不深入了解。)
        方法内、代码块、构造器


3、成员内部类的具体使用
见代码“twelve.demo4”


注：这个知识点不怎么常用，后面遇到了再来进一步了解。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                        一些主观题

1、
抽象类可以实现接口、继承非抽象的类；


2、抽象类与接口的区别？
不同：
    抽象类有构造器（子类调用），接口没有；
    一个类可以实现多个接口；
    接口是一种极度抽象的类型，它比抽象类更加“抽象”，抽象类中可以定义成员变量，
而接口中定义的成员变量实际上都是常量。


相同：
    都不能被实例化；都可以被类实现或者继承；
    


3、面向对象有哪些特性，如何理解？

封装：
    面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象； 我们在类中编写的方法就是对实现细节的一种封装；
我们编写一个类就是对数据和数据操作的封装。隐藏一切可隐藏的东西，只向外界提供最简单的编程接口；


继承：
    从已有类得到继承信息创建新类的过程；子类在父类的基础上进一步地扩展。


多态：用同样的对象引用调用同样的方法但是做了不同的事情。
    多态性分为编译时的多态性和运行时的多态性。（不是很理解，后面用到再说吧！）
    方法重载(overload)实现的是编译时多态性(也称为前绑定)， 
而方法重写(override)实现的是运行时多态性(也称为后绑定)。
    
    实现运行时多态的两个条件：第一，方法重写(子类继承父类并重写父类中已有的或抽象的方法)；
第二：对象造型(用父类型引用指向子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为)。


抽象：
    抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。
抽象只关注对象有哪些属性和行为。



4、Java中为什么要用 clone？

4.1、浅克隆与深克隆
    浅克隆：创建一个新对象(新的地址)，新对象的属性和原来对象完全相同，对于对象中的
非基本类型属性，仍指向原有属性所指向的对象的内存地址。
    深克隆：创建一个新对象，对象属性中引用的其他对象也会被克隆，不再指向原有对象地址。
    

4.2 借助clone方法来实现深/浅克隆
见代码twelve.demo5

4.3、 clone（）与new的区别？

相同之处：
clone()与new都能创建对象。

不同之处:
clone()不会调用构造方法；
new会调用构造方法（在JVM中申请一个空的内存区域，对象的属性值要通过构造方法赋值。）

注：后面有需要再来进一步理解！



5、构造方法与普通方法的区别？


普通方法必须有返回值类型修饰符, 而构造方法不能有返回值类型修饰符;
构造方法名必须和类名相同；
普通方法用来定义对象的行为, 而构造方法用来初始化；

6、super()或者this():为什么一定要定义在第一行？
    因为super()和this()是调用的父类或本类的无参构造器，因为Java不允许调用没有初始化的成员。
只有使用了super()或this()来初始化了对象之后, 才能调用该对象并继续进行后续操作。
    
注：后面有需要再来进一步理解！

7、native关键字
    native 用来修饰方法，简单地讲，一个native Method就是一个 Java 调用非 Java
代码的接口。
    在日常编程中看到native修饰的方法，只需要知道这个方法的作用即可。

8、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？
答：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

注：面向对象就先到这里告一段落即可，后面有需要再来补充！

―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            异常（代码案例见thirteenday-demo）
1、
在程序执行过程中，将程序执行中发生的不正常情况称为“异常”。

异常分类
Throwable
    |--Error	严重的问题，不需要处理
    |--Exception
        |--RuntimeException 一般不处理。
        |--非RuntimeException	是需要进行处理的，否则编译不通过。（编写代码时需要爆红处理的）

注：
    常见的异常分类情况见图片笔记；

2、处理异常的方案
A:try...catch...finally
变形:
try...catch...
try...catch...catch...catch...
try...catch...finally
try...catch...catch...catch...finally
try...finally


B:throws
把问题抛出

注：建议使用A处理方案。实在解决不了，使用B方案。


3、手动生成异常（使用throw；之前的异常是系统帮我们捕捉的）： 


throws和throw的区别？
A:throws
方法声明上,后面跟的是类名,用逗号隔开，可以跟多个。表示可能有异常
B:throw
方法体中,后面跟的是对象名,只能跟一个。用于手动生成一个异常。


注：异常部分就先到这里！

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            写一个小项目《开发团队调度软件》
涉及的知识点：
    面向对象；异常处理


具体实现见project03即可！

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                                   线程

1、
程序：一段为了完成某个特定任务的静态代码。
进程：正在运行的一个程序，是一个动态的过程；资源分配的单位。
线程：程序内部的一条执行路径；调度与执行的单位；一个进程中可以有多个线程，
每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。

2、
单核对应并发（一个cpu同时执行多个任务）
多核对应并行（多个cpu做多个事情）


3、多线程的案例 （见xiancheng的demo案例即可）
线程的5个状态：
    新建：new Thread();
    就绪：start()执行
    运行：run()执行
    死亡：run()执行结束或者异常终止
    阻塞：正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以
    获得CPU时间，进入运行状态。



4、线程同步（见xiancheng的demo案例即可）
    同步就是协同步调，按预定的先后次序进行运行。
    线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。
线程互斥可以看成是一种特殊的线程同步。


5、线程死锁（没有敲案例的必要）
    线程双方各自占用了对方所需的同步资源不放手，并都在等待对方放弃自己所需的同步资源。
这时，所有的线程都处于阻塞状态，无法继续。


6、Lock锁
java同步机制的一种新手段。具体案例见Demo4。


面试题： 
lock与synchronized的异同？
    相同：都是解决线程安全问题的手段
    不同：
        synchronized在执行完相应的同步代码后，自动释放监视器；lock需要手动地加锁与解锁。
        lock只有代码块锁。
        使用lock，jvm性能更好，扩展性更好(lock有更多子类)！

建议使用优先顺序：lock、同步代码块、同步方法


7、线程通信
案例见demo6

面试题：
    sleep()与wait()的异同：
        同：都会使线程进入阻塞
        异：
            wait()在Object中声明；sleep在Thread中声明。
            sleep()可以任意场景调用，在同步区域不会释放同步锁；wait()必须在同步代码区域才能用。


8、消费者-生产者
见demo7



9、使用callable接口创建线程
见demo8


10、线程池（第四种创建方式）
见demo9

注：线程池了解到当前这个程度刚好，后面有需要再深究！



11、常见的主观题

1、并发编程三要素
原子性：原子是不可再分割的最小单元，原子性是指一个或多个操作要么全部执行成功，要么全部执行失败。
可见性：一个线程对共享变量的修改，另一个线程能看到（synchronized,volatile，加锁机制）。
有序性：程序的执行顺序按照代码的先后顺序。（同步问题）

2、什么是多线程，多线程的优劣？
定义：多线程是指程序中包含多个流，即在一个程序中可以同时进行多个不同的线程来执行不同的任务。

优点：提高了CPU的利用率。
缺点：内存开销变大、需要解决线程同步。


3、进程与线程区别：
    根本区别：进程是操作系统资源分配的基本单元，而线程是处理器任务调度的和执行的基本单位。
    资源开销：每个进程都有自己独立的代码和数据空间，程序之间的切换会有较大的开销；线程可以看作
轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，
线程之间切换的开销小。
    包含关系：如果一个进程内有多个线程，则执行的过程不是一条线的，而是多条线（多个线程），共同完成；
线程是进程的一部分，可以把线程看作是轻量级的进程。


4、用户线程与守护线程
    用户线程：运行在前台，执行具体任务，如程序的主线程：main函数就是一个用户线程。
    守护线程：运行在后台，为其它前台线程服务，一旦所有线程都执行结束，守护线程会随着JVM
一起结束运行。如垃圾回收线程。

5、死锁形成的四个必要条件？如何避免死锁？

（1）互斥条件：线程对所分配的资源具有排它性，即一个资源只能被一个线程占用，直到该线程被释放。
（2）请求与保持条件：一个线程因请求被占有资源而发生堵塞时，对已获取的资源保持不放。
（3）不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有等自己使用完才释放资源。
（4）循环等待条件：当发生死锁时，所等待的线程必定形成一个环路，死循环造成永久堵塞。

如何避免死锁：破坏其中一个必要条件即可。
比如破坏不剥夺条件：占有部分资源的线程尝试申请其它资源，如果申请不到，可以主动释放它占有的资源。


6、为什么调用start()方法会执行run()方法，为什么不能直接调用run()方法
    如果直接执行了run方法，run方法会被当作一个main线程下的普通方法执行，
并不会在某个线程中去执行它，所以这并不是多线程工作。

7、线程sleep和yield方法有什么区别？
相同：都没有释放锁。
不同：
    sleep()方法使用时需要处理InterruptException异常，而yield没有；
    sleep()执行后进入阻塞状态，醒来后进入就绪状态，而yield是直接进入就绪状态。

8、同步代码块和同步方法怎么选？
    同步方法会锁住整个对象，哪怕这个类中有不关联的同步块，这通常会导致停止继续执行，
并等待获取这个对象锁。
    同步块扩展性比较好，只需要锁住代码块里面相应的对象即可，可以避免死锁的产生（少锁一些资源）。


9、什么是线程安全？
    线程安全是指某个方法在多线程的环境下被调用时，能够正确处理多线程之间的共享变量，
能程序能够正确完成。

10、
    线程同步：当一个线程对共享数据进行操作的时候，在没有完成相关操作时，不允许其它的线程来打断它，
否则就会破坏数据的完整性，必然会引起错误信息，这就是线程同步。

11、乐观锁与悲观锁
    乐观锁：每个去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会
判断一下在此期间有没有去更新这个数据。所以乐观锁使用了多读的场合。
    悲观锁：总是假设最坏的情况，每次去拿数据的时候都会认为有人会修改，所以每次在拿数据的时候
都会上锁。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            String相关类的详细介绍
1、String
    String实现了"Serializable"接口（支持序列化）：
        把对象转换为字节序列的过程称为对象的序列化。
        什么时候需要序列化：把内存中的对象状态保存到一个文件中或者数据库中时候。

    String实现了"Comparable"接口（支持比较大小）。

    String的不可变性：
        初始的字符串值在内存中已经固定下来了，所以称它是不可变的，
    但String类型的引用变量本身还可以被赋值指向另一个字符串（理解到这里就行了，后面有需要再来深究）。


注：其他细节见Demo1
        

2、StringBuffer与StringBuilder

见Demo2

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                        比较器

Comparable（自然排序）:
    像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，
给出了比较两个对象大小的方式。
    对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，
重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序。

Comparator（定制排序）：
    后面有需要再了解




注：具体实现见demo；后面有需求再来进一步了解。
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                                 枚举类

见demo即可
注：感觉不是很重要，后面有需要再来学就行。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            注解
1、
annotation就是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取并执行对应的处理。

可以修饰的结构：
    包、类、构造器、方法、成员变量、参数、局部变量的声明。


可以这么说：框架=注解+反射+设计模式（后面跟反射再详细学一遍）



注：具体案例见demo;后面结合反射再学一波即可。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                                集合框架

1、集合、数组都是对多个数据进行存储（内存层面的存储）操作的结构，简称java容器。

数组一旦初始化之后，其长度就固定了；数组存储的特点：有序、可重复。


2、集合框架
分为两个体系：Collection接口、Map接口
Collection：单列数据，定义了存取一组对象方法的集合。
    List：元素有序(存储元素时，按数组的索引顺序存元素)、可重复的集合。相当于动态数组。
        ArrayList：
        LinkedList：
        Vector：


    Set:元素无序、不可重复的集合
        HashSet：
            LinkedHashset：
        TreeSet:


Map：双列数据、存取键值对的集合。
    HashMap:
    LinkedHashMap:
    TreeMap:
    HashTable:
    Properties:

 
3、迭代器
    Iterator仅用于遍历集合，Iterator本身并不存放对象。
    所有实现了Collection接口的集合类都有一个iterator()方法，
可以返回一个迭代器。

注：具体实现见demo


4、List接口
面试题：ArrayList、LinkedList、Vector三者的区别？
相同：
    都实现了List接口；存储数据特点相同：有序、可重复。
不同：
    ArrayList：线程不安全、效率高；底层使用数组实现。（常用）
    LinkedList：线程不安全、对于插入删除操作，效率比ArrayList高；底层用双向链表实现。
    Vector：线程安全效率低；底层也用数组实现。（不常用）


5、Set接口（无序（根据哈希表的哈希值来定存储顺序）且不重复）

    HashSet：最常用；线程不安全；可以存null值；底层数据结构是哈希表，因此具有很好的存取和查找性能。
        LinkedHashset：hashset的子类；同时使用链表维护元素的次序，这样使得元素是以插入的顺序保存的。
    TreeSet:treeSet内部实现的是红黑树，默认整形排序为从小到大。

注：见demo小案例


6、Map
6.1、    HashMap:最常用；线程不安全但效率高；可存储空的key和value。
        LinkedHashMap:在HashMap的基础上，添加了一对指针（指向前一个与后一个元素。）；
                保证在遍历元素时，可以按照添加的顺序实现遍历。
    TreeMap（线程不安全）:底层使用红黑树实现。保证按照添加的“key-value”进行排序。
    Hashtable:古老实现类；线程安全但效率低；不可存储空的key和value。
        Properites:常用来处理配置文件。key与value都是String类型。



面试题：
    HashMap的底层实现原理（jdk8）?
        数组+链表+红黑树;后面感兴趣再来了解！

    HashMap与Hashtable的异同？



6.2、map结构的理解
    map的key：无序且不可重复，使用set存储所有的key；
    map的value：无且可重复，使用collection存储所有的value；
    一个键值对：key-value构成一个entry对象；
    map的entry：无序不可重复；使用set存储所有的entry；




6.3、集合的几个练习题

见demo即可




6.4、一些面试题

1、Java中Collection和Collections的区别？
    Collection是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。
Collection接口在Java类库中有很多具体的实现。Collection接口的意义是为各种
具体的集合提供最大化的统一操作方式。
    Collections是一个包装类。它包含各种有关集合操作的静态多态方法。此类不能实例化，
就像一个工具类，服务于Java的Collection框架。


2、如何理解数据结构？
简单地说，就是程序设计优化的方法论。
研究数据逻辑结构与物理结构以及它们之间的相互关系，并对这种结构定义相应的运算。
目的是使得程序的时间复杂度与空间复杂度尽可能小。

数据结构让程序尽可能高效地完成任务；算法让程序正确地把问题解决。

数据结构静态地描述了数据元素之间的关系； 高效地程序就是在数据结构的基础上设计算法。

总结：数据结构是算法解决问题的一个载体。

3、集合的基本概念：
集合是放数据对象引用的容器；
集合存储的对象可以是不同引用类型；
集合可变长度的。
提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；

4、 ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。
它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，
HashEntry则用于存储键-值对数据。

注：就先了解到这！



5、迭代器
    Iterator 接口提供遍历任何 Collection 的接口（所有Collection接继承了Iterator迭代器）。
迭代器允许调用者在迭代过程中移除元素。

注：这个东西感觉一直很抽象，后面有需要再来深入了解！

6、Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。
    如果一个数据集合实现了该接口，就意味着它支持 Random Access，
按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。

注：RandomAccess 接口就了解到这里！


7、 ArrayList 的优缺点
优点：
ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。
ArrayList 在顺序添加一个元素的时候非常方便。
缺点：删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。

8、ArrayList 和 LinkedList 的区别是什么？
可以类比数据结构中的顺序表与链表结构
 


9、hasnmap的实现原理？

保留数据有两种形式：
    数组：寻址容易但删除与插入困难
    链表：寻址难但插入删除容易。

将数组（开放地址法：当某个地址被占用后，继续找下一个地址）与链表（链地址法：相同探测地址的对象组成一个链表放在对应槽位）结合

在1.8之后，
当链表数大于8时，自动转化为红黑树。

    红黑树是一种二叉排序树。与平衡二叉树（avl树）不同的是，
红黑树是弱平衡二叉树，即它的左右子树高度差有可能大于1，但不超过一倍。


10、 HashMap与Hashtable的异同？
线程安全；效率；对Null key 和Null value的支持；
初始容量大小和每次扩充容量大小的不同；
    底层数据结构不同： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 
没有这样的机制。
推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，
推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。


11、

1、如何决定使用 HashMap 还是 TreeMap？
    对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。
然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。

2、HashMap 和 ConcurrentHashMap 的区别？
ConcurrentHashMap对整个数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，
而HashMap没有锁机制，不是线程安全的。

HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。

JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟
HashMap1.8的结构一样，数组+链表/红黑二叉树。


12、comparable 和 comparator的区别？
comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序
comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序
一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法。



注：集合这章感觉有点乱，目前就先学到这里即可！后面有需要再来深入系统地了解！

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                                泛型（demo见jihe.Demo2）

1、
    泛型的本质是参数化类型，即给类型指定一个参数，然后在使用时再指定此参数具体的值。

2、使用泛型的好处？
    告诉编译器每个集合接收的对象类型是什么，编译器在编译期就会做类型检查，告知是否插入了
错误类型的对象，使得程序更加安全，增强了程序的健壮性。
    消除源代码中的强制类型转换，避免了不必要的装箱、拆箱操作（泛型确定了集合中元素的具体类型）。
    
3、泛型通配符
    无边界通配符“List<?>”：可以是任一类型
    固定上边界“<T extends A>”：接受指定类及其子类类型的数据
    固定下边界“<T supers A>”：接受指定类及其父类类型的数据
注：不能同时指定上下边界。

4、
常见泛型参数名称有如下：
    E： Element (在集合中使用，因为集合中存放的是元素)
    T：Type（Java 类）
    K： Key（键）
    V： Value（值）
    N： Number（数值类型）
    ？： 表示不确定的java类型


5、泛型实现原理？
编译器会在编译期间「擦除」泛型语法并相应的做出一些类型转换动作（运行时就没有泛型的事了）。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                              反射（具体实现见demo）


1、
    加载完类之后，在方法区会产生一个Class类型的对象（一个类只有一个Class对象，包含了完整的类结构信息），
这个对象就像一面镜子，透过它可以看到类的结构。形象地称之为反射。
    java反射提供的功能：
        构造对象、查看并调用一个对象的结构。
    主要api：
        java.lang.class:一个类
        java.lang.reflect.Method:类的方法
        java.lang.reflect.Field:类的成员变量
        java.lang.reflect.constructor:类的构造器



2、如何看待反射跟封装？

2.1、new 对象与反射都可以调用反射结构，开发中用哪个？
直接用new的方式；
反射的特征：动态性（需要什么对象就创建什么对象）：
    程序在运行状态中，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；
对于任意一个对象，都能够调用它的任意一个方法和属性。


2.2、反射跟封装冲突吗？
封装：站在程序员角度我们需要这些来约束和规范自己的开发和编码规范。
反射：在我们不知道对象的内部结构但是又不得已非得用到他的时候。比如在
各大框架的编写中我们能发现，为了能动态的产生用户需要的对象。


3、Class类的理解
“.java”文件经过“javac”编译为“.class”文件；
使用“java”命令后，类加载器将".class"文件加载到内存中成为一个运行时类（Class对象的实例）

类加载器：
    它在JVM外部，把描述类的数据从class字节码文件加载到内存…………，
最终形成可以被虚拟机直接使用的Java类型（在堆中生成一个Class对象）。



哪些类型可以有Class对象？
    接口、数组、class、枚举、注解、基本数据类型、void、Class类本身。


注：类加载的原理理解到这里就行，下次有需要再来深入了解。


4、动态代理（见demo2到demo4）

静态代理：
    业务类认真完成自己的业务即可。其余的附加业务让代理类来做。
    代理类与被代理类在编译期间就被确定下来了。


动态代理：
    一个类:Proxy，Proxy类就是用来创建一个代理对象的类，它提供了很多方法，
但是我们最常用的是newProxyInstance方法。
    一个接口:InvocationHandler ，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会
被转发到实现 InvocationHandler接口类的invoke方法来调用。
    只要是实现了同一个接口的子类，都可以被动态代理。

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
                            java8 新特性

1、lamda表达式
见demo










































    










































    
    
    





    




        
    













    




    


    








    
    
    



































